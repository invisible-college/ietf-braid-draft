Internet-Draft                                                 M. Toomim
Expires: Jan 8, 2020                                   Invisible College
Intended status: Proposed Standard                             R. Walker
                                                       Invisible College
                                                            July 8, 2019

              The Braid Protocol: Synchronization for HTTP
                         draft-toomim-braid-00

                       ____              _     _ 
                      |    |            (_)   | |
                      | |) )  ____ _____ _  __| |
                      |  _ \ / ___)____ | |/ _  |
                      | |_) ) |   / ___ | ( (_| |
                      |____/|_|   \_____|_|\____|

Abstract

  Braid is a proposal for a new version of HTTP that transforms it from
  a state *transfer* protocol into a state *synchronization* protocol.
  Braid puts the power of Operational Transform and CRDTs onto the web,
  improving network performance and robustness, and enabling
  peer-to-peer web applications.
  
  At the same time, Braid creates an open standard for the dynamic
  internal state of websites.  Programmers can access state uniformly,
  whether local or on another website.  This creates a separation of UI
  from State, and allows any user to edit or choose their own UI for any
  website's state.

  We have a working prototype of the Braid, and have deployed it with
  production websites.  This document describes the protocol, how it
  differs from prior versions of HTTP, and a plan to deploy it in a
  backwards-compatible way, where web developers can opt into the new
  synchronization features without breaking the rest of the web.



Status of this Memo

  This Internet-Draft is submitted in full conformance with the
  provisions of BCP 78 and BCP 79.
  
  Internet-Drafts are working documents of the Internet Engineering Task
  Force (IETF), its areas, and its working groups.  Note that other
  groups may also distribute working documents as Internet-Drafts.  The
  list of current Internet-Drafts is at
  http://datatracker.ietf.org/drafts/current/.

  Internet-Drafts are draft documents valid for a maximum of six months
  and may be updated, replaced, or obsoleted by other documents at any
  time.  It is inappropriate to use Internet-Drafts as reference
  material or to cite them other than as "work in progress."

  The list of current Internet-Drafts can be accessed at
  https://www.ietf.org/1id-abstracts.html

  The list of Internet-Draft Shadow Directories can be accessed at
  https://www.ietf.org/shadow.html




==================
== Introduction ==

  HTTP was initially designed to transfer static pages.  If a page
  changes, it is the client's responsibility to issue another GET
  request.  This made sense when pages were static and written by hand.
  However, today's websites are dynamic, generated from databases, and
  continuously mutate as their state changes.  Now we need state
  *synchronization*, not just state *transfer*.

  Unfortunately, there is no standard way to synchronize.  Instead,
  programmers write non-standard code; wiring together custom protocols
  over WebSockets and long-polling XMLHTTPrequests with stacks of
  Javascript frameworks.  The task of connecting a UI with data is one
  that every dynamic website has to do, but there is no standard way to
  do it.

      ======= HTTP Websites =======      ====== Braid Websites ======

      Today's websites are               Braid generalizes HTTP and
      generated from multiple            REST into a uniform standard
      layers of state across             that synchronizes state
      multiple computers.  Each          within and between dynamic
      layer has a different API.         websites.

        x Non-standard state API          o Standard state API

        _Client__
       /         \ 
      :  o o o o  :   Webpage DOM          o o o o       State
      :   \|  \|  :                         \|  \|  
      :    x   x  :   HTML Templates         o   o       State
      :   /|  /|  :                         /|  /|  
      :  x x x x  :   JS Models            o o o o       State
       \ | | | | /                         | | | |  
         | | | |                           | | | |
         o o o o    - http:// -            o o o o     - braid:// -
       / | | | | \                         | | | | 
      :  x x x x  :   Views                o o o o       State
      :  |  \| |  :                        |  \| |   
      :  x   x x  :   Controllers          o   o o       State
      :   \ / \|  :                         \ / \| 
      :    x   x  :   Models                 o   o       State
      :     \ /   :                           \ /
       \.... x ../    Database                 o         State
         Server

      Today's programmers have to        On the braid, each piece of
      learn each API, and wire them      state (o) has a URL; whether
      together, making sure that         public, or internal to a
      changes to shared state            client or server.  Any state
      synchronize across all             can be a function of other
      layers and computers.              state, and dynamically
                                         recomputes when its
                                         dependencies change.  Braid
                                         guarantees the network will
                                         synchronize.



  As the web becomes more dynamic and data-driven, the complexity of the
  non-standard Javascript stack grows, and an increasing amount of data
  is inaccessible to the open web.  The result is a web which is open on
  the surface, but closed internally: websites can link to each other's
  *pages*, but cannot easily share each other's internal *state*.

  We can solve this by generalizing HTTP into a *synchronization*
  protocol, which replaces the complex Javascript stack, while providing
  new features, and making website internal state accessible anywhere
  desired, and realtime synchronized by default.

  We have a working prototype of the Braid protocol, and have deployed
  it with production websites.  The prototype is implemented as a
  polyfill library, which adds Braid features to existing browsers and
  servers.

  This document describes the new protocol, how it differs from prior
  versions of HTTP, and a plan to deploy it in a backwards-compatible
  way, where web developers can opt into the new synchronization
  features without breaking the rest of the web.



=====================
== Synchronization ==

  Braid incorporates the abilities of Operational Transform and CRDTs.
  These are approaches to solving *synchronization*.

  Synchronization is a problem that occurs whenever two or more
  computers or threads access the same state.  Synchronization code is
  tricky to write, and can result in clobbers, corruptions, or race
  conditions.

  This is a challenging problem, which has seen a number of partial
  attempts in HTTP (e-tags, cache control, PATCH, JSON-diff, SSE) [cite,
  cite, cite, cite, cite].

  Luckily, a set of maturing synchronization technologies (such as
  Operational Transform and CRDTs) can now automate and encapsulate
  synchronization within a library.  They can synchronize arbitrary JSON
  data structures across an arbitrary set of computers that make
  arbitrary mutations, and consistently merge their edits into a valid
  result, without a central server, in the face of arbitrary network
  delays and dropouts.  In other words, it is now possible to interact
  with state stored anywhere on a network as if it is a local variable,
  and program as if it is already downloaded and always up-to-date.

  Unfortunately, each synchronizer implements a different protocol, with
  a different set of features and tradeoffs.  But we have found that
  their network messages actually encode the same information, and that
  we can encode a standard protocol, that different synchronizers can
  interoperate over.  This means they can even theoretically
  interoperate, if they specify and agree on a way to consistently
  resolve ambiguities.  We have run successful tests interoperating a
  CRDT [1] and OT [2] system, for instance, over the common Braid
  protocol.

  Braid proposes a common language for synchronizers, so that they can
  interoperate, and embeds it as an extension to HTTP.


  When applying synchronization to the web, we see the power of
  synchronization manifest in these concrete ways:


    - Caches update automatically and instantly, because servers promise
      to push changes to their subscribers.  This obsoletes the
      `cache-control` and `refresh` headers, and the `max-age`
      heuristic.  Users never need to force-clear their cache.

    - Updates go over the network as diffs, which can be much smaller
      than the resources they modify, significantly reducing network
      usage.

    - Web apps get an offline mode for free.  Edits from multiple
      clients merge automatically once they come online.  Network
      failures recover transparently.

    - *Reload* buttons in browsers become unnecessary, and can be
      removed for braid sites.  Browsers automatically discover and
      display the most recent version on their own.

    - Web apps require roughly 70% less code to build (in our
      experiments), because programmers do not need web frameworks or
      custom logic to wire together a stack of server-state and
      client-state.  This work is automated by the protocol.

    - Every <textarea> can become a collaborative editor (like Google
      Docs) for free.

    - Servers become optional.  Many apps can function without a server,
      because peers can synchronize with one another directly over the
      protocol.

    - In standardizing synchronization, we implicitly create a standard
      for state. This allows state to be shared between different sites
      without the need for an extra API.
    
    - Standardizing the representation of *state* allows us to separate
      the representation of UI and state. Most HTTP websites *inject*
      the state that they receive into templates representing UI
      components. Braid sites can instead understand UI components as
      lenses through which to view state. This improves the semantics of
      UI rendering, allows state to be inspected by clients directly,
      and makes it easier to build multiple alternative UIs for a single
      site.

  Standardized state and synchronization allows the topology of content
  on the web to be less centralized.

           Closed Networks

        -  -              -  -       Before the web, people used
     /        \        /        \    closed networks like America
    |   x   x  |      |   x  x   |   Online.  Content was
    |          |      |          |   encapsulated behind
     \    x   /        \    x   /    proprietary protocols.
        -  -              -  -
        Aol            Compuserve



             HTTP Websites

        -  o--------------o  -       The web lets any site define
     /        o--------o        \    *pages* at URLs.  A site can
    |   x   x  o------o   x  x   |   *link* to another site's pages,
    |          o------o          o   adding value to both sites.
     \    x   o        o    x   /
        -  o--------------o  -
       Facebook         NY Times



             Braid Websites
                                     
        o--o    _---------o  o       The braid lets any site define
        |/    o'-------o  |  |       *states* at URLs.  A state can
    o---o---o---------o---o--o---o   be a *function* of other states.
       / \ / \ o------o    \  \      When a state changes, the others
      o   o---o \__.   o    o   o    automatically synchronize with it,
        o--o        `-----o--o       like a spreadsheet.
      My Stuff         Your Stuff



========================================================================
|                    Deployment and Upgrade Plan                       |

  Braid proposes basic changes to HTTP and REST, which create an
  opportunity to unify a number of disparate features (SSE, E-tags,
  Cache-control, PATCH, JSON-Diff) within a simple integrated design.

  Rather than shoe-horn these changes into the existing HTTP semantics,
  we propose a new simpler layer, with a backwards-compatible mapping to
  HTTP's existing semantics.  This allows existing applications to
  interoperate, but new applications can opt-in to a simpler web API
  that provides more synchronization features.
 
  We can deploy these semantics in two phases:

    1. The first phase requires no changes to existing web browsers,
       making it easy for users to experiment with the protocol's
       semantics in existing websites.

       In this phase, browsers fetch the initial HTML page over the
       existing HTTP protocol, which includes Javascript code, that
       initiates a WebSocket connection that runs the Braid protocol.
       This WebSocket version of the Braid protocol provides the full
       synchronization functionality, but is less performant --
       requiring an extra round-trip to initiate.

    2. If and when the WebSocket protocol stabilizes and achieves
       real-world adoption, we can add the Braid semantics into HTTP
       itself, in a new layer via an HTTP Upgrade header [RFC 2616,
       section 14.42].
       
  Both versions of the protocol can maintain backwards-compatibility
  with existing HTTP clients and servers.  Any client accessing a Braid
  server via HTTP 1,2 or 3 will be able to GET, PUT, and POST Braid
  state, but without full synchronization capabilities.  Likewise, Braid
  clients can access state on HTTP servers, but will have to poll the
  server for updates.


========================================================================
|                      Proposed Changes to HTTP                        |

  Braid is composed of a set of opt-in changes that any browser or
  server can implement.

  Whereas HTTP is explicitly client/server, Braid is capable of running
  peer-to-peer.

  To do this, it generalizes the explicit request/response pattern of
  HTTP into a set of common messages, opened over a persistent two-way
  connection.


Generalized request/response

  In HTTP, a client sends a *request* to the server, and that request is
  met with a *response*. By contrast, a Braid connection is two-way, so
  messages can be initiated by either party. Rather than giving a
  response to a message, a Braid server sends a separate message that
  acts as the response. It turns out that a GET response message has the
  same effect on a peer as a SET request message-- both set the state on
  the recipient.

  --------------------------------------------------------------
  | HTTP         | Braid       | Meaning                       |
  | ------------ | ----------- | ----------------------------- |
  | Get Request  | Get message | "I want this"                 |
  | Get Response | Set message | "This is the current version" |
  | Put Request  | Set message | "This is the current version" |
  | Put Response | Ack message | "I accept this version"       |
  --------------------------------------------------------------


Subscriptions

  In the Braid model, whenever a client requests some state, it also
  subscribes to new versions of that state. This requires only minor
  changes to the semantics of HTTP.

  In the Braid protocol, a GET message not only returns the current
  value of state, but also *subscribes* to future updates.  The
  subscription continues until the client sends a FORGET. Finally,
  Braid unifies the PUT, POST, and PATCH methods in to a single
  SET method, which is able to both create state and change state.

  ---------------------------------------------------------------------
  | HTTP method    | Braid method | What's new                        |
  | -------------- | ------------ | --------------------------------- | 
  | Get            | Get          | Also subscribes to future updates |
  | - n/a -        | Forget       | Ends a "Get" subscription         |
  | Put/Post/Patch | Set          | Also updates all subscribers      |
  | Delete         | Delete       | Also updates all subscribers      |
  ---------------------------------------------------------------------
  
  In their simplest forms, these messages are otherwise semantically
  identical to their corresponding HTTP methods.  When robust
  synchronization is required, these messages will include optional
  *versioning* features.



Versioning

  Even though there are many synchronizers, it is possible for them to
  communicate in a common language.  Different synchronizers use
  different data structures internally, and have different network
  messages-- however, the *information* they send can all be represented
  with a common set of objects:

   - VERSIONS  define points in time,  irrespective of space
   - LOCATIONS define points of space, irrespective of time
   - PATCHES replace regions of space, across spans of time

  These three objects are enough to represent any type of change to a
  JSON data structure.  (We have verified this by encoding the
  network messages of ShareDB and Automerge in these objects and they
  still work.)

  However, synchronizers also differ in how they resolve conflicting
  changes to the same region of state.  We can generalize the behavior
  of these resolvers by adding *merge types*:

   - MERGE TYPES define how edits to the same location resolve

  If a synchronizer expresses state changes using versions, locations,
  and patches, and specifies its merge types, then it can synchronize
  with any other braid synchronizer implementing the same merge types,
  no matter their internal implementation.

  Finally, synchronizers also broadcast *acknowledgements* of the
  versions they have received, in order to tell their peers that they
  have moved forward in time, and will no longer refer to old history
  when sending patches.  This allows their peers to prune their history
  logs, and free up unused memory:

   - ACKNOWLEDGEMENTS of versions allow peers to prune historical memory

  The rest of this section explains how these concepts work together.


  == VERSIONS ==
  
  Time on a network is ambiguous as a result of latency. If multiple
  peers perform actions without communicating the results, we cannot say
  that one happened before the other, and time has forked. If both of
  those actions are observed within the same period, then their
  concurrent observation results in a merge.
 
  Thus the shape of time is not a line but a Directed Acyclic Graph-- a
  DAG. When an action is taken, a new version in time is created. This
  version has *parents*, which are all of the parallel versions that the
  acting client had seen when it took the action. The new version is
  then the *child* of its parents. We can say that one version came
  before another only if the first version is an *ancestor* of the
  second-- that is, starting from the later version, the earlier can be
  reached by repeatedly traveling from child to parent.
 
         (O)    All peers are aware of the initial condition (O).
         / \
        /   \
      (A)   (B) Two peers make simultaneous edits creating versions (A)
        \   /   and (B) respectively, and time forks.
         \ /
         (M)    Once a peer sees both of the edits, time merges again.
                Until a peer makes an edit with (A) and (B) as parents,
                the merge is only implicit-- there is no need for to
                assign an ID to it.
  
  Every version is identified by an *ID*. There is no requirement on the
  format of the ID, only that it be a unique string. For full
  interoperability, implementations of the protocol are encouraged to
  use arbitrary hashes as IDs. Nonetheless, some implementations might
  JSON-encode a vector clock or linear version number in their IDs.
  
  When a version is initially created, peers will usually send it as a
  patch (with respect to the implicit merge of its parents), along with
  its ID and the IDs of its parents.

  == PATCHES ==

  When a peer changes some state, it encodes that change as a patch. 
  A SET message will include the 'patches' key as an array of patches.
  All patches are replace operations, referencing a region of space and
  what it should be replaced with. The region of space is formatted as
  an index or key into the target object (which is specified as part of
  the SET message). The format of the patch is:
  
                "(obj)location = value"
  
  Insertions are implemented as replacing a zero-length region with a
  non-zero-length region, and deletes replace a non-zero length region
  with a zero-length one.
  
  Here are some example patches targeting object 'obj' 
  (ie, {set: 'obj', patches: [...]} )
  
    .foo[0].bar = null       # Replace obj.foo[0].bar with null
    
    [3:3] = "asdf"           # Insert the string 'asdf' at index 3 of
                               string obj. Illegal if array.
    [3] = "a"                # Set char 3 of string obj to 'a'
                               or element 3 of array obj to 'a'
    [3] = "asdf"             # Illegal if string.
                               If array, set obj[3] to 'asdf'
    [3:4] = [1, 3, 5]        # Splice [1,3,5] into array obj, replacing
                               element 3. Illegal if string.
    [4:4] = [{msg: "hi"}]    # Insert an object at the end of array obj
    
    [3:10] = ""              # Delete characters 3-10 in string obj
    
    = false                  # Set the entire object obj to false
    
    .foo[0].bar = undefined  # Delete obj.foo[0].bar


  == MERGE TYPES ==
  
  Different applications want to resolve conflicts in different ways.
  For instance, strings in a collaborative text editor will want to
  merge clobbering edits by inserting everything typed, and deleting
  everything deleted, and breaking ordering ties arbitrarily; but if two
  debits to a bank account balance occur in parallel, we will want to
  merge the debits by adding the differences together.
  
  When the time DAG has multiple leaves (versions with no children), the
  current state can only be understood as a merge of the leaves. We give
  each piece of state a merge type, which specifies formally how
  the leaves should be merged. Each piece of state can have its own
  merge type, which will be communicated with the first SET message.
  
  Tentatively, the merge type is a string which is the name of a
  specific, hardcoded resolution strategy. Braid implementations will
  understand various common merge types. As long as all peers understand
  the specified merge type, they will converge to a consistent result.
  
  Note that in practice, the resolver corresponding with a merge type 
  might not actually be implemented as a modular function. Real-world OT
  systems bake resolution into their transformation steps, and CRDTs
  bake it into their data structures and read functions. However, no
  matter the structure of their internal code, any system can specify
  its resolution strategy abstractly as a merge type: as a standard way
  to describe how to interoperate with it. In other words, merge types
  specify the end behavor, not the implementation.



================
== Conclusion ==


Security Considerations

IANA Considerations

  This document has no actions for IANA.

Copyright Notice

  Copyright (c) 2019 IETF Trust and the persons identified as the
  document authors.  All rights reserved.

  This document is subject to BCP 78 and the IETF Trust's Legal
  Provisions Relating to IETF Documents
  (http://trustee.ietf.org/license-info) in effect on the date of
  publication of this document.  Please review these documents
  carefully, as they describe your rights and restrictions with respect
  to this document.  Code Components extracted from this document must
  include Simplified BSD License text as described in Section 4.e of the
  Trust Legal Provisions and are provided without warranty as described
  in the Simplified BSD License.


Author's Address

  Michael Toomim
  Invisible College, Berkeley
  2053 Berkeley Way
  Berkeley, CA 94704

  Email: toomim@gmail.com
  Web:   https://invisible.college/@toomim

  Rafie Walker
  Invisible College, Berkeley
  2053 Berkeley Way
  Berkeley, CA 94704

  Email: slickytail.mc@gmail.com
